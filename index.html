<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Интерактивное Кино</title>
    <!-- Подключение Tailwind CSS для стилей -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Установка шрифта Inter -->
    <style>
        /* Общие стили для максимального погружения */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000000; /* Черный фон */
            margin: 0;
            padding: 0;
            overflow: hidden; /* Убираем скролл */
            color: #ffffff;
        }

        /* Видео заполняет весь экран (задний план) */
        #video-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 10;
            /* Начинаем с невидимого видео, чтобы избежать вспышки */
            opacity: 0; 
            transition: opacity 1s ease;
        }
        #game-video {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Видео полностью покрывает область */
            pointer-events: none; /* Запрещает взаимодействие с видео */
            transition: filter 0.5s ease; /* Добавляем плавный переход для фильтра */
        }
        
        /* Эффект заморозки и обесцвечивания */
        #game-video.frozen {
            filter: grayscale(100%); /* Делает видео черно-белым */
        }

        /* Стиль загрузочного экрана */
        #loading-screen {
            position: fixed;
            inset: 0;
            background-color: #000000;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s ease-in-out;
            cursor: default;
        }
        /* Анимация мигания для текста "З А Г Р У З К А" */
        .animate-pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: .5; }
        }

        /* Интерфейс (контейнер выбора) - только позиционирование */
        #movie-interface {
            position: fixed;
            bottom: 50px; /* Отступ снизу */
            right: 50px; /* Отступ справа */
            left: 50px; /* Добавили отступ слева, чтобы можно было центрировать кнопку */
            z-index: 20;
            width: auto; /* Ширина по контенту */
            padding: 0;
            transform: translateY(100px); /* Скрыто ниже */
            opacity: 0;
            visibility: hidden; /* Гарантированно скрыто */
            transition: transform 0.5s ease, opacity 0.5s ease, visibility 0.5s; 
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: flex-end; /* Выравнивание кнопок по правому краю */
        }

        #movie-interface.active {
            transform: translateY(0); /* Показываем контейнер */
            opacity: 1;
            visibility: visible !important; /* Принудительно показываем */
            pointer-events: auto;
        }
        
        /* Специальный стиль для центрирования одной кнопки "Н А Ч А Т Ь" */
        #movie-interface.centered {
            align-items: center; /* Центрируем содержимое по горизонтали */
        }


        /* Адаптивность для мобильных */
        @media (max-width: 640px) {
            #movie-interface {
                bottom: 20px;
                right: 20px;
                left: 20px;
                align-items: center; /* Центрируем кнопки на мобильном */
            }
            #choices-container {
                flex-direction: column;
                gap: 0.75rem;
            }
        }

        /* Стиль кнопок: Белый текст с черным ореолом (текст-тень) */
        .choice-btn {
            background-color: transparent;
            border: none;
            color: #ffffff; /* Белый текст */
            text-align: right;
            font-weight: 700; /* Жирный текст */
            font-size: 1.25rem; /* Увеличенный размер */
            padding: 0.5rem 0.75rem; /* Минимальный padding для удобства клика */
            border-radius: 0.25rem;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap; /* Чтобы текст не переносился, если помещается */
            /* Черная тень вокруг текста для контраста */
            text-shadow: 0 0 4px #000000, 0 0 4px #000000, 0 0 6px #000000;
        }
        .choice-btn:hover {
            /* Усиление свечения (белая тень) и черного ореола */
            text-shadow: 0 0 15px #ffffff, 0 0 10px #000000, 0 0 8px #000000;
            background-color: rgba(0, 0, 0, 0.4); /* Легкая темная подсветка фона при наведении */
            transform: scale(1.05); /* Небольшое увеличение */
        }
        /* Стиль для кнопки "Пустошь" на начальном экране */
        #wasteland-start-btn {
            background-color: #fff;
            color: #000;
            text-shadow: none;
            padding: 1rem 3rem;
            border-radius: 9999px; /* Круглые края */
            font-size: 1.5rem;
            box-shadow: 0 4px 15px rgba(255, 255, 255, 0.3);
            font-weight: 700;
        }
        #wasteland-start-btn:hover {
            box-shadow: 0 6px 20px rgba(255, 255, 255, 0.5);
            background-color: #eee;
        }
    </style>
</head>
<body>

    <!-- Загрузочный экран -->
    <div id="loading-screen">
        <!-- Текст, который будет меняться. На старте будет скрыт, потом показан для загрузки. -->
        <p id="loading-title" class="text-4xl text-white font-bold tracking-widest hidden">И Н Т Е Р А К Т И В Н О Е</p>
        <p id="loading-status" class="text-xl text-gray-300 mt-2 hidden">К И Н О: П У С Т О Ш Ь</p>
        
        <!-- Кнопка будет добавлена через JS в showStartButtonScreen -->
    </div>
    
    <!-- Музыка загрузки -->
    <audio id="loading-audio" loop src="https://files.catbox.moe/e81wbk.mp3"></audio>

    <!-- Контейнер для видео (Задний план) -->
    <div id="video-container">
        <video id="game-video" muted>
            Ваш браузер не поддерживает тег video.
        </video>
    </div>

    <!-- Новые аудио-элементы для звуковых эффектов и фоновой музыки сцен -->
    <audio id="scene-effect-audio" preload="auto"></audio>
    <audio id="scene-music-audio" preload="auto" loop></audio>

    <!-- Интерфейс игры (Контейнер только для кнопок выбора) -->
    <div id="movie-interface"> 
        
        <!-- Контейнер для кнопок выбора -->
        <div id="choices-container" class="flex flex-col space-y-3 w-full">
            
            <!-- Скрытые элементы для отладки -->
            <div class="hidden">
                 <div id="narrative-text"></div> 
            </div>
        </div>
    </div>

    <script type="module">

        // --- КОНСТАНТЫ СЮЖЕТА И ХРАНЕНИЯ ---
        const LOCAL_STORAGE_KEY = 'movieGameProgress';
        
        // Константы для IndexedDB
        const DB_NAME = 'MovieGameCacheDB';
        const STORE_NAME = 'assetStore';
        const DB_VERSION = 1;

        // Определяем структуру сюжета игры
        const story = {
            'start': {
                videoUrl: 'https://files.catbox.moe/gwba6a.mp4', 
                text: 'Начальная сцена, нет выбора.',
                choices: [] 
            },
            // Сцена 01: Бесшовный переход (autoAdvance)
            'scene_01': { 
                videoUrl: 'https://files.catbox.moe/xsoldv.mp4',
                text: 'Продолжение первой сцены.',
                choices: [], 
                autoAdvance: 'scene_01_transition' // Автоматический переход после завершения видео
            },
            // Сцена перехода: Бесшовный переход (autoAdvance)
            'scene_01_transition': {
                videoUrl: 'https://files.catbox.moe/m3px4x.mp4', 
                text: 'Короткий переход к месту, где нужно принимать решение.',
                choices: [],
                autoAdvance: 'scene_01_a' // Автоматический переход
            },
            // Сцена 1A: Первый настоящий выбор
            'scene_01_a': {
                // Визуальный плейсхолдер вместо повторяющегося видео
                videoUrl: 'https://placehold.co/1280x720/000000/FFFFFF?text=СЦЕНА+1A%0A%0A(ВЫБОР+КОДА/СПРЯТАТЬСЯ)',
                text: 'Фонарик освещает дверь с кодовым замком. Вдалеке слышны шаги. Вы попробуете ввести код или спрятаться?',
                choices: [
                    { text: 'Ввести случайный код (4 цифры)', nextId: 'scene_02_fail' },
                    { text: 'Спрятаться за ящиками', nextId: 'scene_02_success' }
                ]
            },
            'scene_01_b': {
                videoUrl: 'https://placehold.co/1280x720/000000/FFFFFF?text=СЦЕНА+1B%0A%0A(ТУПИК)',
                text: 'Карта показывает выход, но вы не видите, куда идти в темноте. Шаги приближаются. Что делать?',
                choices: []
            },
            'scene_02_success': {
                videoUrl: 'https://placehold.co/1280x720/000000/FFFFFF?text=СЦЕНА+2%0A%0A(УСПЕХ)',
                text: 'Вам удалось избежать опасности! Вы находите ключ от двери. Теперь вы можете выйти.',
                choices: [
                    { text: 'Использовать ключ и выйти', nextId: 'end_win' }
                ]
            },
            'scene_02_fail': {
                videoUrl: 'https://placehold.co/1280x720/000000/FFFFFF?text=СЦЕНА+2%0A%0A(ПРОВАЛ+и+ЭФФЕКТ)',
                text: 'Выбор был неудачным. Дверь не открывается, а шаги достигают вашей комнаты. Игра окончена.',
                choices: [
                    { text: 'Начать новую игру', nextId: 'start' }
                ],
                effectAudio: 'https://files.catbox.moe/zuo7xz.mp3' 
            },
            'end_win': {
                videoUrl: 'https://placehold.co/1280x720/000000/FFFFFF?text=ФИНАЛ%0A%0A(ПОБЕДА+И+МУЗЫКА)',
                text: 'Поздравляем! Вы прошли через все испытания и выбрались на свободу. Продолжение следует...',
                choices: [
                    { text: 'Начать новую игру', nextId: 'start' }
                ],
                musicAudio: 'https://files.catbox.moe/64kb40.mp3', // Музыка для финала
                musicVolume: 0.3 
            }
        };

        // --- Элементы DOM ---
        const loadingScreen = document.getElementById('loading-screen');
        const loadingTitle = document.getElementById('loading-title'); 
        const loadingStatus = document.getElementById('loading-status');
        const loadingAudio = document.getElementById('loading-audio');
        const movieInterface = document.getElementById('movie-interface');
        const videoContainer = document.getElementById('video-container');
        const videoElement = document.getElementById('game-video');
        const choicesContainer = document.getElementById('choices-container');
        const narrativeText = document.getElementById('narrative-text'); 
        const sceneEffectAudio = document.getElementById('scene-effect-audio');
        const sceneMusicAudio = document.getElementById('scene-music-audio');
        
        // Маппинг для хранения Blob URL (локально закэшированных ссылок в памяти)
        const assetCacheMap = new Map(); 

        // --- IndexedDB УТИЛИТЫ ДЛЯ КЭШИРОВАНИЯ ---

        /** Открывает соединение с базой данных IndexedDB. */
        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onerror = event => {
                    console.error('Ошибка IndexedDB:', event.target.error);
                    reject(event.target.error);
                };
                request.onsuccess = event => resolve(event.target.result);
                request.onupgradeneeded = event => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        // Создаем хранилище объектов. URL будет ключом.
                        db.createObjectStore(STORE_NAME);
                        console.log('Создано хранилище IndexedDB:', STORE_NAME);
                    }
                };
            });
        }

        /** Сохраняет ассет (Blob) в IndexedDB по его URL. */
        function saveAssetToDB(db, url, blob) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.put(blob, url);

                request.onsuccess = () => resolve();
                request.onerror = event => {
                    console.error(`Ошибка сохранения ассета ${url}:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }

        /** Получает ассет (Blob) из IndexedDB по его URL. */
        function getAssetFromDB(db, url) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get(url);

                request.onsuccess = event => resolve(event.target.result || null); // Возвращаем Blob или null
                request.onerror = event => {
                    console.error(`Ошибка получения ассета ${url}:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }
        
        // --- ФУНКЦИИ ПРОГРЕССА (Local Storage) ---
        function saveProgress(sceneId) {
            try {
                localStorage.setItem(LOCAL_STORAGE_KEY, sceneId);
            } catch (error) {
                console.error("Ошибка при сохранении локального прогресса:", error);
            }
        }

        function loadProgressLocal() {
            try {
                const savedSceneId = localStorage.getItem(LOCAL_STORAGE_KEY);
                return savedSceneId || 'start';
            } catch (error) {
                return 'start';
            }
        }

        // --- ПРЕДВАРИТЕЛЬНАЯ ЗАГРУЗКА АССЕТОВ (С ИНДЕКСИРОВАННОЙ БАЗОЙ ДАННЫХ) ---

        /**
         * Принудительно загружает ассет (видео или аудио) и создает локальный Blob URL.
         * Сначала проверяет IndexedDB, затем сеть.
         */
        async function preloadAsset(url) {
            // Пропускаем, если уже закэшировано в оперативной памяти
            if (assetCacheMap.has(url)) return;

            let blob;
            let db;

            // Пропускаем плейсхолдеры, так как они не являются реальными файлами для загрузки
            if (!url.includes('http')) {
                assetCacheMap.set(url, url);
                return;
            }

            try {
                db = await openDB();
                
                // 1. Попытка получить из IndexedDB
                const cachedBlob = await getAssetFromDB(db, url);

                if (cachedBlob) {
                    // console.log(`[КЭШ] Ассет загружен из IndexedDB: ${url}`);
                    blob = cachedBlob;
                } else {
                    // 2. Загрузка из сети
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    blob = await response.blob();

                    // 3. Сохранение в IndexedDB для постоянного кэша
                    await saveAssetToDB(db, url, blob);
                    // console.log(`[КЭШ] Ассет загружен из сети и сохранен в IndexedDB: ${url}`);
                }
                
                // 4. Создание Blob URL и сохранение в оперативной памяти (для использования в DOM)
                const blobUrl = URL.createObjectURL(blob);
                assetCacheMap.set(url, blobUrl);

            } catch (error) {
                console.error(`Ошибка кэширования или загрузки ассета: ${url}. Будет использована исходная ссылка.`, error);
                // Fallback: сохраняем исходный URL, если IndexedDB или fetch не сработали
                assetCacheMap.set(url, url); 
            }
        }

        async function preloadAssets() {
            
            const allUrls = new Set();
            Object.values(story).forEach(scene => {
                if (scene.videoUrl) allUrls.add(scene.videoUrl);
                if (scene.effectAudio) allUrls.add(scene.effectAudio);
                if (scene.musicAudio) allUrls.add(scene.musicAudio);
            });
            
            // Фильтруем только те, что имеют http/https для загрузки
            const assetUrls = Array.from(allUrls).filter(url => url && url.includes('http'));

            const totalAssets = assetUrls.length;
            let loadedCount = 0;

            const preloadPromises = assetUrls.map(url => 
                preloadAsset(url).then(() => {
                    loadedCount++;
                    // Обновляем статус, показывая прогресс загрузки
                    loadingStatus.textContent = `Загрузка ассетов: ${loadedCount} из ${totalAssets}...`;
                })
            );
            
            loadingStatus.textContent = `Загрузка ассетов: ${loadedCount} из ${totalAssets}...`;
            
            await Promise.all(preloadPromises);
            
            loadingStatus.textContent = 'Загрузка завершена. Ждите клика...';
        }

        // --- ОБРАБОТЧИКИ СЦЕН И ИГРЫ ---

        function handleSceneEnd(sceneId) {
            const scene = story[sceneId];
            
            // 1. ПРИОРИТЕТ: БЕСШОВНЫЙ ПЕРЕХОД (autoAdvance)
            if (scene.autoAdvance) {
                // НЕ ПАУЗИМ, НЕ МОРОЗИМ. Просто загружаем следующий клип.
                console.log(`Автоматический (бесшовный) переход к сцене: ${scene.autoAdvance}`);
                // Очень маленькая задержка, чтобы браузер успел обработать onended
                setTimeout(() => {
                    saveProgress(scene.autoAdvance);
                    loadScene(scene.autoAdvance);
                }, 50); 
                return;
            }
            
            // 2. Сцена 'start' (специальный случай для кнопки "НАЧАТЬ")
            if (sceneId === 'start') {
                videoElement.pause(); // Пауза, чтобы видео не перезапустилось
                videoElement.classList.add('frozen'); 
                movieInterface.classList.add('active', 'centered'); 
                
                // Создаем кнопку "Н А Ч А Т Ь"
                const button = document.createElement('button');
                button.textContent = 'Н А Ч А Т Ь';
                button.className = 'choice-btn transition duration-200 ease-in-out text-2xl px-8 py-4'; 
                
                button.onclick = () => {
                    movieInterface.classList.remove('active', 'centered');
                    saveProgress('scene_01');
                    loadScene('scene_01');
                };
                choicesContainer.appendChild(button);
                return;
            }

            // 3. ВСЕ ОСТАЛЬНЫЕ СЦЕНЫ (С ВЫБОРОМ ИЛИ КОНЦОВКИ)

            // Замораживаем и делаем серым
            videoElement.pause();
            videoElement.classList.add('frozen'); 

            // Очищаем старые кнопки
            choicesContainer.innerHTML = '';
            movieInterface.classList.remove('active', 'centered');

            if (scene.choices.length > 0) {
                // Это сцена с выбором (включая end_win/end_fail с кнопкой "Начать заново")
                 movieInterface.classList.remove('centered');
                 movieInterface.classList.add('active');
                 // Кнопки уже созданы в loadScene, просто показываем интерфейс
                 return;
            } else {
                // Это конечная сцена без выбора (например, тупиковая ветка)
                console.log("Достигнута конечная сцена без активного выбора.");
            }
        }

        function loadScene(sceneId) {
            const scene = story[sceneId];
            if (!scene) {
                console.error(`Сцена с ID "${sceneId}" не найдена. Переход на 'start'.`);
                return loadScene('start');
            }
            
            // 1. Скрываем интерфейс и убираем серый фильтр
            movieInterface.classList.remove('active', 'centered');
            videoElement.classList.remove('frozen'); 
            
            // --- УПРАВЛЕНИЕ АУДИО СЦЕНЫ ---
            sceneEffectAudio.pause();
            sceneEffectAudio.currentTime = 0;
            sceneMusicAudio.pause();
            sceneMusicAudio.currentTime = 0;
            
            if (scene.effectAudio) {
                sceneEffectAudio.src = assetCacheMap.get(scene.effectAudio) || scene.effectAudio;
                sceneEffectAudio.load();
                sceneEffectAudio.play().catch(e => console.warn("Не удалось запустить эффект аудио:", e));
            }

            if (scene.musicAudio) {
                const musicUrl = assetCacheMap.get(scene.musicAudio) || scene.musicAudio;
                const volume = scene.musicVolume !== undefined ? scene.musicVolume : 1.0;
                
                console.log(`[АУДИО] Попытка запустить фоновую музыку для сцены ${sceneId}: ${musicUrl} с громкостью ${volume}`);
                
                sceneMusicAudio.src = musicUrl;
                sceneMusicAudio.volume = volume; 
                sceneMusicAudio.load();
                sceneMusicAudio.play().catch(e => console.warn("Не удалось запустить фоновую музыку:", e));
            }
            // -----------------------------
            
            // 2. Обновляем видео и запускаем (используя кэшированный URL)
            videoElement.src = assetCacheMap.get(scene.videoUrl) || scene.videoUrl;
            videoElement.load();
            videoElement.muted = false; 
            
            // 3. Устанавливаем обработчик onended для этой сцены
            videoElement.onended = () => handleSceneEnd(sceneId);

            videoElement.play().catch(e => {
                console.log("Ошибка автозапуска видео:", e);
                // Если не удалось автовоспроизведение, показываем интерфейс
                movieInterface.classList.add('active');
            });

            // 4. Обновляем текст и рендерим кнопки
            narrativeText.textContent = scene.text; 
            choicesContainer.innerHTML = ''; 

            if (scene.choices && scene.choices.length > 0) {
                scene.choices.forEach(choice => {
                    const button = document.createElement('button');
                    button.textContent = choice.text;
                    button.className = 'choice-btn transition duration-200 ease-in-out text-base text-right';
                    
                    button.onclick = () => {
                        Array.from(choicesContainer.children).forEach(btn => btn.disabled = true);
                        
                        saveProgress(choice.nextId);
                        loadScene(choice.nextId);
                    };
                    choicesContainer.appendChild(button);
                });
            }
        }

        // --- УПРАВЛЕНИЕ ЗАГРУЗКОЙ И СТАРТОМ ---

        function showStartButtonScreen() {
            loadingScreen.removeEventListener('click', startGame);
            loadingScreen.innerHTML = ''; 

            const startButton = document.createElement('button');
            startButton.id = 'wasteland-start-btn';
            startButton.textContent = 'В О Й Т И   В   П У С Т О Ш Ь';
            startButton.className = 'mt-0'; 
            
            loadingScreen.appendChild(startButton);
            startButton.onclick = startLoading;
        }

        function startLoading() {
            
            // 1. Запускаем музыку ПЕРВЫМ ДЕЛОМ, привязывая ее к клику
            loadingAudio.volume = 0.5; 
            loadingAudio.play().catch(e => console.warn("Не удалось запустить музыку.", e));

            // 2. Убираем кнопку
            const startButton = document.getElementById('wasteland-start-btn');
            if (startButton) startButton.remove();
            
            // 3. Добавляем обратно элементы текста загрузки в DOM
            loadingScreen.appendChild(loadingTitle);
            loadingScreen.appendChild(loadingStatus);
            
            // 4. Обновляем текст загрузки и делаем видимым
            loadingTitle.classList.remove('hidden');
            loadingStatus.classList.remove('hidden');
            loadingTitle.textContent = 'З А Г Р У З К А';
            loadingTitle.classList.add('animate-pulse');
            loadingStatus.textContent = 'Проверка кэша и загрузка ассетов...';

            // 5. Начинаем загрузку ассетов (теперь с проверкой IndexedDB)
            preloadAssets().then(() => {
                // 6. Когда загрузка завершена, переходим к экрану готовности
                showReadyScreen();
            });
        }

        function showReadyScreen() {
            loadingTitle.textContent = 'Н А Ж М И Т Е';
            loadingTitle.classList.remove('animate-pulse');
            loadingStatus.textContent = 'чтобы начать игру (кэш проверен)';
            
            loadingScreen.style.cursor = 'pointer';
            loadingScreen.addEventListener('click', startGame, { once: true });
        }
        
        function startGame() {
            // 1. Плавное скрытие загрузочного экрана
            loadingScreen.style.opacity = '0';
            
            setTimeout(() => {
                loadingScreen.remove();
                loadingAudio.pause(); // Останавливаем загрузочную музыку
                
                videoContainer.style.opacity = '1'; 
                
                const currentSceneId = loadProgressLocal();
                loadScene(currentSceneId);

            }, 500); 
        }

        // --- Инициализация игры ---
        showStartButtonScreen(); 
    </script>
</body>
</html>
