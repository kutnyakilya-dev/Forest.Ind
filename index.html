<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Приложение для Схватки</title>
    <!-- Подключаем Tailwind CSS для стилей -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Устанавливаем шрифт Inter по умолчанию и черный фон для всего тела */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000000;
            color: #ffffff;
            height: 100vh;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        /* Анимация вращающегося лоадера */
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .spinner {
            border-top-color: #f87171; /* Красный цвет для спиннера */
            animation: spin 1s linear infinite;
        }
        /* Убеждаемся, что канвас не имеет фиксированной высоты, чтобы он мог заполнить весь экран */
        #visualizer-canvas {
            background-color: transparent; /* Канвас должен быть прозрачным */
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'custom-red': '#dc2626', /* Интенсивный красный для кнопки */
                        'custom-red-hover': '#b91c1c',
                    }
                }
            }
        }
    </script>
</head>
<body>

    <!-- 1. Экран Загрузки (Loading Screen) -->
    <div id="loading-screen" class="absolute inset-0 flex flex-col items-center justify-center transition-opacity duration-1000 bg-black z-20">
        <!-- Спиннер -->
        <div class="spinner w-12 h-12 border-4 border-gray-700 rounded-full"></div>
        <p class="mt-4 text-xl text-gray-400" id="loading-message">
            Проверяем кэш...
        </p>
        <p class="mt-2 text-sm text-gray-500">
            (Настоящая загрузка файлов симулируется задержкой)
        </p>
    </div>

    <!-- 2. Основной Экран (Main Screen) -->
    <div id="main-screen" class="hidden absolute inset-0 flex flex-col items-center justify-center transition-opacity duration-1000 bg-black z-10">
        <h1 class="text-4xl sm:text-6xl font-extrabold mb-8 text-gray-100">ПОЛЕ БИТВЫ</h1>
        <p class="text-xl text-gray-400 mb-12">
            Вы готовы к схватке?
        </p>
        <!-- Красная Кнопка -->
        <button id="start-button" class="px-12 py-4 text-xl font-bold rounded-xl shadow-lg transition duration-300 ease-in-out bg-custom-red hover:bg-custom-red-hover active:bg-red-700 transform hover:scale-105">
            НАЧАТЬ СХВАТКУ
        </button>
    </div>
    
    <!-- 3. Экран Видео (Video Screen) -->
    <div id="video-screen" class="hidden absolute inset-0 bg-black flex items-center justify-center z-10">
        <!-- Контейнер, заполняющий весь экран и содержащий видео и визуализатор -->
        <div class="relative w-full h-full">
            <!-- Видео на заднем плане, растянуто на весь экран -->
            <!-- object-cover обеспечивает полноэкранное отображение вертикального видео -->
            <video id="battle-video" class="w-full h-full object-cover absolute top-0 left-0" autoplay crossorigin="anonymous" muted></video>
            
            <!-- Визуализатор поверх видео, ПОЛНОЭКРАННЫЙ -->
            <canvas id="visualizer-canvas" class="absolute inset-0 z-20"></canvas>
            
            <!-- Индикатор загрузки видео (поверх) -->
            <div id="video-loading" class="absolute inset-0 bg-black bg-opacity-75 flex flex-col items-center justify-center hidden z-30">
                <div class="spinner w-16 h-16 border-8 border-gray-600 rounded-full"></div>
                <p class="mt-4 text-xl text-gray-300">Загрузка видео...</p>
            </div>
        </div>
    </div>


    <!-- Кастомное Модальное Сообщение (вместо alert) -->
    <div id="message-box" class="hidden fixed top-0 left-0 w-full h-full bg-black bg-opacity-75 flex items-center justify-center z-50">
        <div class="bg-gray-800 p-6 rounded-xl shadow-2xl max-w-sm text-center">
            <p class="text-white text-lg mb-4" id="box-message"></p>
            <button onclick="document.getElementById('message-box').classList.add('hidden')" class="bg-custom-red text-white px-4 py-2 rounded-lg hover:bg-custom-red-hover">Закрыть</button>
        </div>
    </div>


    <script type="text/javascript">
        // Инициализация элементов
        const loadingScreen = document.getElementById('loading-screen');
        const mainScreen = document.getElementById('main-screen');
        const videoScreen = document.getElementById('video-screen');
        const battleVideo = document.getElementById('battle-video');
        const visualizerCanvas = document.getElementById('visualizer-canvas');
        const canvasCtx = visualizerCanvas.getContext('2d');
        const loadingMessage = document.getElementById('loading-message');
        const startButton = document.getElementById('start-button');
        const messageBox = document.getElementById('message-box');
        const boxMessage = document.getElementById('box-message');
        const videoLoading = document.getElementById('video-loading'); 

        // Ключ для кэша в localStorage
        const CACHE_KEY = 'appCacheLoaded';
        
        // =================================================================
        // ВАШ СПИСОК ВИДЕО
        // =================================================================
        const VIDEO_LIST = [
            'https://files.catbox.moe/y09yxd.mp4', // Видео 1
            // Добавьте больше видео по необходимости: 'ваш_url_видео_2.mp4',
        ];
        let currentVideoIndex = 0;
        
        // =================================================================
        // НАСТРОЙКИ АУДИО ВИЗУАЛИЗАТОРА (Круглые волны)
        // =================================================================
        let audioCtx = null;
        let analyser = null;
        let source = null;
        let freqDataArray = null; // Данные частотной области (для пульсации)
        let bufferLength = 0;
        let animationFrameId = null;

        /**
         * Инициализирует Web Audio API. Должен быть вызван после взаимодействия с пользователем.
         */
        function initAudioContext() {
            if (audioCtx) return; 

            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 1024; // Оптимально для частотного анализа
                bufferLength = analyser.frequencyBinCount; // 512
                
                freqDataArray = new Uint8Array(bufferLength); // 512 частот

                source = audioCtx.createMediaElementSource(battleVideo);
                source.connect(analyser);
                analyser.connect(audioCtx.destination);
                
                // Устанавливаем unmute, так как браузеры могут блокировать autoplay со звуком
                battleVideo.muted = false;

                console.log("AudioContext успешно инициализирован.");
            } catch (e) {
                console.error("Ошибка инициализации AudioContext:", e);
                visualizerCanvas.style.display = 'none'; 
                showMessage("Ошибка инициализации аудио для визуализатора. Проверьте, что видеофайл доступен по CORS.");
            }
        }

        /**
         * Отрисовывает визуализатор частот на холсте в виде круга.
         */
        function drawVisualizer() {
            animationFrameId = requestAnimationFrame(drawVisualizer);

            if (!analyser || !freqDataArray) return;

            // 1. Очищаем холст (используем прозрачность, чтобы видеть видео)
            canvasCtx.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height); 
            
            // 2. Получаем данные частот
            analyser.getByteFrequencyData(freqDataArray); 

            const WIDTH = visualizerCanvas.width;
            const HEIGHT = visualizerCanvas.height;
            const centerX = WIDTH / 2;
            const centerY = HEIGHT / 2;
            // Размер круга зависит от наименьшей стороны экрана
            const baseRadius = Math.min(WIDTH, HEIGHT) / 4; 
            const barCount = 128; // Количество сегментов в круге
            const dataStep = Math.floor(bufferLength / barCount);
            
            // 3. Анализ Бас-Энергии (для эффекта "дергания" и свечения)
            let bassEnergy = 0;
            // Анализируем первые 10 частотных корзин для низких частот
            const BASS_BINS = 10; 
            for (let i = 0; i < BASS_BINS; i++) {
                bassEnergy += freqDataArray[i];
            }
            
            // Нормализация энергии баса (0..1)
            const normalizedBass = (bassEnergy / (255 * BASS_BINS)); 
            // Амплитуда волны: базовая 1.0, с басом до 1.4
            const amplitudeScale = 1.0 + normalizedBass * 0.4; 
            
            // 4. Настройка стилей для круга (Яркий Пурпурный Неон)
            canvasCtx.strokeStyle = '#FF00FF'; // Маджента
            canvasCtx.lineWidth = 4; 
            canvasCtx.shadowColor = '#FF00FF';
            // Свечение зависит от громкости баса
            canvasCtx.shadowBlur = 10 + normalizedBass * 25; 

            canvasCtx.beginPath();
            
            // 5. Отрисовка пульсирующей круговой волны
            for(let i = 0; i <= barCount; i++) {
                const angle = i * 2 * Math.PI / barCount;
                const dataIndex = i * dataStep;
                
                // Значение частоты (0-255)
                const freqValue = freqDataArray[dataIndex] || 0;
                // Нормализованная амплитуда (0..1)
                const normalizedAmplitude = freqValue / 255; 
                
                // Текущий радиус = Базовый Радиус + (Амплитуда * Максимальное Отклонение * Масштаб Баса)
                const maxDeviation = baseRadius * 0.5;
                const currentRadius = baseRadius + (normalizedAmplitude * maxDeviation * amplitudeScale);

                const x = centerX + currentRadius * Math.cos(angle);
                const y = centerY + currentRadius * Math.sin(angle);

                if (i === 0) {
                    canvasCtx.moveTo(x, y);
                } else {
                    canvasCtx.lineTo(x, y);
                }
            }
            canvasCtx.closePath();
            canvasCtx.stroke();
            
            // Сброс тени
            canvasCtx.shadowBlur = 0; 
            
            // 6. Отрисовка радиальных линий (Фоновый эффект, как на картинке)
            canvasCtx.strokeStyle = 'rgba(180, 0, 180, 0.4)'; // Темно-пурпурный
            canvasCtx.lineWidth = 1;
            
            for(let i = 0; i < barCount; i++) {
                const angle = i * 2 * Math.PI / barCount;
                const dataIndex = i * dataStep;
                const freqValue = freqDataArray[dataIndex] || 0;
                const normalizedValue = freqValue / 255; 
                
                // Длина линии зависит от частоты
                const lineLength = normalizedValue * baseRadius * 0.7; 

                canvasCtx.beginPath();
                // Линия идет от внутреннего края круга наружу
                const innerX = centerX + (baseRadius * 0.9) * Math.cos(angle);
                const innerY = centerY + (baseRadius * 0.9) * Math.sin(angle);
                
                const outerX = centerX + (baseRadius * 0.9 + lineLength) * Math.cos(angle);
                const outerY = centerY + (baseRadius * 0.9 + lineLength) * Math.sin(angle);
                
                canvasCtx.moveTo(innerX, innerY); 
                canvasCtx.lineTo(outerX, outerY);
                canvasCtx.stroke();
            }

            // 7. Центральная заливка (для чистоты)
            canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.5)'; // Полупрозрачный черный
            canvasCtx.beginPath();
            canvasCtx.arc(centerX, centerY, baseRadius * 0.9, 0, 2 * Math.PI);
            canvasCtx.fill();
        }

        /**
         * Устанавливает размеры холста в соответствии с размерами окна (полноэкранный режим).
         */
        function resizeCanvas() {
            // Размеры холста должны соответствовать размерам окна для полноэкранного визуализатора
            visualizerCanvas.width = window.innerWidth;
            visualizerCanvas.height = window.innerHeight;
            
            if (animationFrameId) {
                drawVisualizer(); 
            }
        }

        /**
         * Отображает кастомное модальное сообщение (вместо alert()).
         * @param {string} message Сообщение для отображения.
         */
        function showMessage(message) {
            boxMessage.textContent = message;
            messageBox.classList.remove('hidden');
        }

        /**
         * Симулирует загрузку ресурсов (с кэшированием видео).
         */
        async function simulateLoad() {
            const isFirstLoad = localStorage.getItem(CACHE_KEY) === null;
            const startTime = performance.now();
            let messageText;
            const minLoadTime = 500; 

            if (isFirstLoad) {
                messageText = 'Кэш не найден. Первая загрузка будет долгой: загружаем все видео...';
                loadingMessage.textContent = messageText;

                try {
                    const fetchPromises = VIDEO_LIST.map(url => 
                        fetch(url, { mode: 'cors', cache: 'force-cache' }) 
                    );
                    
                    await Promise.all(fetchPromises);
                    
                    const elapsed = performance.now() - startTime;
                    const remainingTime = Math.max(0, 3000 - elapsed); 

                    await new Promise(resolve => setTimeout(resolve, remainingTime));
                    
                    localStorage.setItem(CACHE_KEY, 'true');
                    messageText = 'Видео успешно закэшированы! Теперь все будет быстро.';

                } catch (e) {
                    console.error("Ошибка при предварительной загрузке видео:", e);
                    messageText = 'Ошибка кэширования. Продолжаем, но загрузка может быть долгой.';
                    await new Promise(resolve => setTimeout(resolve, 3000)); 
                }

            } else {
                messageText = 'Кэш найден! Загрузка займет всего полсекунды.';
                loadingMessage.textContent = messageText;
                await new Promise(resolve => setTimeout(resolve, minLoadTime));
            }

            loadingMessage.textContent = messageText; 
            loadingScreen.style.opacity = '0';
            
            setTimeout(() => {
                loadingScreen.classList.add('hidden');
                mainScreen.classList.remove('hidden');
                mainScreen.style.opacity = '1'; 
            }, 1000);
        }
        
        /**
         * Воспроизводит видео по заданному индексу.
         */
        function playVideo(index) {
            if (index >= VIDEO_LIST.length) {
                showMessage("Схватка окончена! Все видео были показаны.");
                currentVideoIndex = 0; 
                
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                
                videoScreen.classList.add('hidden');
                mainScreen.classList.remove('hidden');
                return;
            }

            currentVideoIndex = index;
            battleVideo.src = VIDEO_LIST[currentVideoIndex];
            videoLoading.classList.remove('hidden'); 
            
            battleVideo.load();
            
            battleVideo.play().then(() => {
                videoLoading.classList.add('hidden'); 
                
                if (audioCtx && audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
                
                if (!animationFrameId && analyser) {
                    drawVisualizer(); 
                }
            }).catch(e => {
                videoLoading.classList.add('hidden'); 
                console.error(`Ошибка при воспроизведении видео №${index + 1} (${VIDEO_LIST[currentVideoIndex]}):`, e);
                showMessage(`Ошибка воспроизведения видео №${index + 1}.`);
                playVideo(currentVideoIndex + 1);
            });
        }
        
        /**
         * Запускает последовательное воспроизведение видео.
         */
        function startBattle() {
            // Инициализация AudioContext и размеров Canvas должна произойти после клика пользователя
            initAudioContext();
            resizeCanvas(); 
            
            mainScreen.classList.add('hidden');
            videoScreen.classList.remove('hidden');
            
            currentVideoIndex = 0; 
            playVideo(currentVideoIndex);
        }


        // =================================================================
        // СЛУШАТЕЛИ СОБЫТИЙ
        // =================================================================

        // Запуск симуляции загрузки при старте
        window.onload = () => {
            simulateLoad();
            resizeCanvas(); 
        };

        // Обработчик кнопки "Начать схватку"
        startButton.addEventListener('click', startBattle);
        
        // Обработчик для автоматического переключения видео, когда текущее заканчивается
        battleVideo.addEventListener('ended', () => {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            playVideo(currentVideoIndex + 1);
        });
        
        // Остановка визуализатора при паузе
        battleVideo.addEventListener('pause', () => {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        });
        
        // Запуск визуализатора при возобновлении воспроизведения
        battleVideo.addEventListener('play', () => {
            // Возобновление AudioContext после взаимодействия пользователя, если он был приостановлен
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            if (!animationFrameId && analyser) {
                drawVisualizer();
            }
        });
        
        // Слушатель для изменения размера окна (для адаптивности визуализатора)
        window.addEventListener('resize', resizeCanvas);
        
        // Повторный вызов resizeCanvas, чтобы убедиться, что он работает корректно
        window.setTimeout(resizeCanvas, 100);

    </script>

</body>
</html>