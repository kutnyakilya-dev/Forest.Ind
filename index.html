<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Интерактивное Кино</title>
    <!-- Подключение Tailwind CSS для стилей -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Установка шрифта Inter -->
    <style>
        /* Общие стили для максимального погружения */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000000; /* Черный фон */
            margin: 0;
            padding: 0;
            overflow: hidden; /* Убираем скролл */
            color: #ffffff;
        }

        /* Видео заполняет весь экран (задний план) */
        #video-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 10;
            /* Начинаем с невидимого видео, чтобы избежать вспышки */
            opacity: 0; 
            transition: opacity 1s ease;
        }
        #game-video {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Видео полностью покрывает область */
            pointer-events: none; /* Запрещает взаимодействие с видео */
            transition: filter 0.5s ease; /* Добавляем плавный переход для фильтра */
        }
        
        /* НОВАЯ КЛАССА: Эффект заморозки и обесцвечивания */
        #game-video.frozen {
            filter: grayscale(100%); /* Делает видео черно-белым */
        }

        /* Стиль загрузочного экрана */
        #loading-screen {
            position: fixed;
            inset: 0;
            background-color: #000000;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s ease-in-out;
            cursor: default;
        }
        /* Анимация мигания для текста "З А Г Р У З К А" */
        .animate-pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: .5; }
        }

        /* Интерфейс (контейнер выбора) - только позиционирование */
        #movie-interface {
            position: fixed;
            bottom: 50px; /* Отступ снизу */
            right: 50px; /* Отступ справа */
            left: 50px; /* Добавили отступ слева, чтобы можно было центрировать кнопку */
            z-index: 20;
            width: auto; /* Ширина по контенту */
            padding: 0;
            transform: translateY(100px); /* Скрыто ниже */
            opacity: 0;
            visibility: hidden; /* Гарантированно скрыто */
            transition: transform 0.5s ease, opacity 0.5s ease, visibility 0.5s; 
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: flex-end; /* Выравнивание кнопок по правому краю */
        }

        #movie-interface.active {
            transform: translateY(0); /* Показываем контейнер */
            opacity: 1;
            visibility: visible !important; /* Принудительно показываем */
            pointer-events: auto;
        }
        
        /* Специальный стиль для центрирования одной кнопки "Н А Ч А Т Ь" */
        #movie-interface.centered {
            align-items: center; /* Центрируем содержимое по горизонтали */
        }


        /* Адаптивность для мобильных */
        @media (max-width: 640px) {
            #movie-interface {
                bottom: 20px;
                right: 20px;
                left: 20px;
                align-items: center; /* Центрируем кнопки на мобильном */
            }
            #choices-container {
                flex-direction: column;
                gap: 0.75rem;
            }
        }

        /* Стиль кнопок: Белый текст с черным ореолом (текст-тень) */
        .choice-btn {
            background-color: transparent;
            border: none;
            color: #ffffff; /* Белый текст */
            text-align: right;
            font-weight: 700; /* Жирный текст */
            font-size: 1.25rem; /* Увеличенный размер */
            padding: 0.5rem 0.75rem; /* Минимальный padding для удобства клика */
            border-radius: 0.25rem;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap; /* Чтобы текст не переносился, если помещается */
            /* Черная тень вокруг текста для контраста */
            text-shadow: 0 0 4px #000000, 0 0 4px #000000, 0 0 6px #000000;
        }
        .choice-btn:hover {
            /* Усиление свечения (белая тень) и черного ореола */
            text-shadow: 0 0 15px #ffffff, 0 0 10px #000000, 0 0 8px #000000;
            background-color: rgba(0, 0, 0, 0.4); /* Легкая темная подсветка фона при наведении */
            transform: scale(1.05); /* Небольшое увеличение */
        }
        /* Стиль для кнопки "Пустошь" на начальном экране */
        #wasteland-start-btn {
            background-color: #fff;
            color: #000;
            text-shadow: none;
            padding: 1rem 3rem;
            border-radius: 9999px; /* Круглые края */
            font-size: 1.5rem;
            box-shadow: 0 4px 15px rgba(255, 255, 255, 0.3);
            font-weight: 700;
        }
        #wasteland-start-btn:hover {
            box-shadow: 0 6px 20px rgba(255, 255, 255, 0.5);
            background-color: #eee;
        }
    </style>
</head>
<body>

    <!-- Загрузочный экран -->
    <div id="loading-screen">
        <!-- Текст, который будет меняться. На старте будет скрыт, потом показан для загрузки. -->
        <p id="loading-title" class="text-4xl text-white font-bold tracking-widest hidden">И Н Т Е Р А К Т И В Н О Е</p>
        <p id="loading-status" class="text-xl text-gray-300 mt-2 hidden">К И Н О: П У С Т О Ш Ь</p>
        
        <!-- Кнопка будет добавлена через JS в showStartButtonScreen -->
    </div>
    
    <!-- Музыка загрузки -->
    <audio id="loading-audio" loop src="https://files.catbox.moe/e81wbk.mp3"></audio>

    <!-- Контейнер для видео (Задний план) -->
    <div id="video-container">
        <video id="game-video" muted>
            Ваш браузер не поддерживает тег video.
        </video>
    </div>

    <!-- Новые аудио-элементы для звуковых эффектов и фоновой музыки сцен -->
    <audio id="scene-effect-audio" preload="auto"></audio>
    <audio id="scene-music-audio" preload="auto" loop></audio>

    <!-- Интерфейс игры (Контейнер только для кнопок выбора) -->
    <div id="movie-interface"> 
        
        <!-- Контейнер для кнопок выбора -->
        <div id="choices-container" class="flex flex-col space-y-3 w-full">
            
            <!-- Скрытые элементы для отладки -->
            <div class="hidden">
                 <div id="narrative-text"></div> 
            </div>
        </div>
    </div>

    <script type="module">

        // Определяем структуру сюжета игры
        const story = {
            // Первая сцена - теперь без вариантов выбора (только кнопка "Н А Ч А Т Ь")
            'start': {
                videoUrl: 'https://files.catbox.moe/gwba6a.mp4', 
                text: 'Начальная сцена, нет выбора.',
                choices: [] 
            },
            // Сцена 01: Теперь ведет к новой переходной сцене
            'scene_01': { 
                videoUrl: 'https://files.catbox.moe/xsoldv.mp4',
                text: 'Продолжение первой сцены.',
                choices: [
                    // Автоматический переход к новой сцене
                    { text: 'Продолжить (Переход)', nextId: 'scene_01_transition' } 
                ]
            },
            // НОВАЯ СЦЕНА: Видео, которое просил Илья, с автоматическим переходом
            'scene_01_transition': {
                videoUrl: 'https://files.catbox.moe/m3px4x.mp4', // НОВЫЙ URL
                text: 'Короткий переход к месту, где нужно принимать решение.',
                choices: [
                    // Автоматический переход к сцене с выбором
                    { text: 'Продолжить (Сцена 1A)', nextId: 'scene_01_a' } 
                ]
            },
            // Сцена 1A: Взяли фонарик (Сцена с РЕАЛЬНЫМ выбором - будет серой и ждать клика)
            'scene_01_a': {
                videoUrl: 'https://archive.org/download/BigBuckBunny_124/Content/big_buck_bunny_720p_stereo.mp4',
                text: 'Фонарик освещает дверь с кодовым замком. Вдалеке слышны шаги. Вы попробуете ввести код или спрятаться?',
                choices: [
                    { text: 'Ввести случайный код (4 цифры)', nextId: 'scene_02_fail' },
                    { text: 'Спрятаться за ящиками', nextId: 'scene_02_success' }
                ]
            },
            // Сцена без выбора (если дойдет сюда, то зависнет на сером экране, как финал)
            'scene_01_b': {
                videoUrl: 'https://archive.org/download/ElephantsDream/ed_hd.mp4',
                text: 'Карта показывает выход, но вы не видите, куда идти в темноте. Шаги приближаются. Что делать?',
                choices: []
            },
            'scene_02_success': {
                videoUrl: 'https://archive.org/download/BigBuckBunny_124/Content/big_buck_bunny_720p_stereo.mp4',
                text: 'Вам удалось избежать опасности! Вы находите ключ от двери. Теперь вы можете выйти.',
                choices: [
                    { text: 'Использовать ключ и выйти', nextId: 'end_win' }
                ]
            },
            'scene_02_fail': {
                videoUrl: 'https://archive.org/download/ElephantsDream/ed_hd.mp4',
                text: 'Выбор был неудачным. Дверь не открывается, а шаги достигают вашей комнаты. Игра окончена.',
                choices: [
                    { text: 'Начать новую игру', nextId: 'start' }
                ],
                // АУДИО ЭФФЕКТ ДЛЯ ПРЕДПОСЛЕДНЕГО КЛИПА
                effectAudio: 'https://files.catbox.moe/zuo7xz.mp3' 
            },
            'end_win': {
                videoUrl: 'https://www.w3schools.com/html/mov_bbb.mp4',
                text: 'Поздравляем! Вы прошли через все испытания и выбрались на свободу. Продолжение следует...',
                choices: [
                    { text: 'Начать новую игру', nextId: 'start' }
                ],
                // ФОНОВАЯ МУЗЫКА ДЛЯ ПОСЛЕДНЕГО КАДРА
                musicAudio: 'https://files.catbox.moe/64kb40.mp3',
                musicVolume: 0.3 // 30% громкости
            }
        };

        const LOCAL_STORAGE_KEY = 'movieGameProgress';

        // --- Элементы DOM ---
        const loadingScreen = document.getElementById('loading-screen');
        // Элементы текста загрузки (скрыты на стартовом экране)
        const loadingTitle = document.getElementById('loading-title'); 
        const loadingStatus = document.getElementById('loading-status');
        
        const loadingAudio = document.getElementById('loading-audio');
        const movieInterface = document.getElementById('movie-interface');
        const videoContainer = document.getElementById('video-container');
        const videoElement = document.getElementById('game-video');
        const choicesContainer = document.getElementById('choices-container');
        const narrativeText = document.getElementById('narrative-text'); 
        
        // Новые аудио-элементы
        const sceneEffectAudio = document.getElementById('scene-effect-audio');
        const sceneMusicAudio = document.getElementById('scene-music-audio');
        
        // Маппинг для хранения Blob URL (локально закэшированных ссылок)
        const assetCacheMap = new Map(); 

        // --- Функции сохранения и загрузки состояния (localStorage) ---

        function saveProgress(sceneId) {
            try {
                localStorage.setItem(LOCAL_STORAGE_KEY, sceneId);
                console.log(`Прогресс сохранен локально: ${sceneId}`);
            } catch (error) {
                console.error("Ошибка при сохранении локального прогресса:", error);
            }
        }

        function loadProgressLocal() {
            try {
                const savedSceneId = localStorage.getItem(LOCAL_STORAGE_KEY);
                return savedSceneId || 'start';
            } catch (error) {
                console.error("Ошибка при загрузке локального прогресса, начинаем с 'start'.", error);
                return 'start';
            }
        }

        // --- Предварительная загрузка ассетов (с принудительным кэшированием) ---

        /**
         * Принудительно загружает ассет (видео или аудио) и создает локальный Blob URL.
         * @param {string} url - Исходный URL ассета.
         * @returns {Promise<void>} - Промис, который завершается после кэширования.
         */
        function preloadAsset(url) {
            // Пропускаем, если уже закэшировано
            if (assetCacheMap.has(url)) return Promise.resolve();

            return fetch(url)
                .then(response => {
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    return response.blob().then(blob => {
                        // Создаем локальный Blob URL и сохраняем его в мапе
                        const blobUrl = URL.createObjectURL(blob);
                        assetCacheMap.set(url, blobUrl);
                    });
                })
                .catch(error => {
                    console.error(`Ошибка при принудительном кэшировании ассета: ${url}. Будет использована исходная ссылка.`, error);
                    assetCacheMap.set(url, url); // Fallback: сохраняем исходный URL
                });
        }

        async function preloadAssets() {
            
            // Собираем все уникальные URL-адреса (видео и аудио)
            const allUrls = new Set();
            Object.values(story).forEach(scene => {
                if (scene.videoUrl) allUrls.add(scene.videoUrl);
                if (scene.effectAudio) allUrls.add(scene.effectAudio);
                if (scene.musicAudio) allUrls.add(scene.musicAudio);
            });
            
            const assetUrls = Array.from(allUrls).filter(url => url && url.includes('http'));

            const totalAssets = assetUrls.length;
            let loadedCount = 0;

            const preloadPromises = assetUrls.map(url => 
                preloadAsset(url).then(() => {
                    loadedCount++;
                    // Обновляем статус, показывая прогресс загрузки
                    loadingStatus.textContent = `Загрузка ассетов: ${loadedCount} из ${totalAssets}...`;
                })
            );
            
            // Начальный статус
            loadingStatus.textContent = `Загрузка ассетов: ${loadedCount} из ${totalAssets}...`;
            
            await Promise.all(preloadPromises);
            
            loadingStatus.textContent = 'Загрузка завершена. Ждите клика...';
        }

        // --- Обработчик окончания сцены ---

        function handleSceneEnd(sceneId) {
            const scene = story[sceneId];
            
            // 1. Замораживаем и делаем серым
            videoElement.pause();
            videoElement.classList.add('frozen'); 

            // 2. Очищаем старые кнопки
            choicesContainer.innerHTML = '';
            movieInterface.classList.remove('active', 'centered');

            const hasManualChoices = scene.choices.length > 0 && !scene.choices[0].text.startsWith('Продолжить');
            const hasAutoTransitionChoice = scene.choices.length === 1 && scene.choices[0].text.startsWith('Продолжить');

            // --- СПЕЦИАЛЬНЫЙ СЛУЧАЙ: Сцена 'start' (кнопка "Н А Ч А Т Ь") ---
            if (sceneId === 'start') {
                movieInterface.classList.add('active', 'centered'); 
                
                const button = document.createElement('button');
                button.textContent = 'Н А Ч А Т Ь';
                button.className = 'choice-btn transition duration-200 ease-in-out text-2xl px-8 py-4'; 
                
                button.onclick = () => {
                    movieInterface.classList.remove('active', 'centered');
                    saveProgress('scene_01');
                    loadScene('scene_01');
                };
                choicesContainer.appendChild(button);
                return;
            }

            // --- СТАНДАРТНЫЙ ВЫБОР (Ручной переход) ---
            if (scene.choices.length > 1 || hasManualChoices) {
                // Если есть настоящий выбор, показываем кнопки и ждем клика
                movieInterface.classList.remove('centered');
                movieInterface.classList.add('active');
                // Кнопки уже созданы в loadScene, просто показываем интерфейс
                return;
            }

            // --- АВТОМАТИЧЕСКИЙ ПЕРЕХОД (Нет выбора или только авто-выбор) ---
            if (scene.choices.length === 0 || hasAutoTransitionChoice) {
                
                // Определяем следующую сцену
                const nextId = hasAutoTransitionChoice ? scene.choices[0].nextId : 'start'; // Если нет, идем в начало

                console.log(`Автоматический переход к сцене: ${nextId}`);
                
                // Немедленно включаем следующую сцену (с небольшой задержкой для удобства)
                setTimeout(() => {
                    saveProgress(nextId);
                    loadScene(nextId);
                }, 500); 
                return;
            }
        }

        // --- Загрузка сцены ---

        function loadScene(sceneId) {
            const scene = story[sceneId];
            if (!scene) {
                console.error(`Сцена с ID "${sceneId}" не найдена. Переход на 'start'.`);
                return loadScene('start');
            }
            
            // 1. Скрываем интерфейс и убираем серый фильтр
            movieInterface.classList.remove('active', 'centered');
            videoElement.classList.remove('frozen'); // Убираем эффект серого цвета
            
            // --- УПРАВЛЕНИЕ АУДИО СЦЕНЫ ---
            
            // Останавливаем все сценные аудио перед загрузкой новой сцены
            sceneEffectAudio.pause();
            sceneEffectAudio.currentTime = 0;
            sceneMusicAudio.pause();
            sceneMusicAudio.currentTime = 0;
            
            if (scene.effectAudio) {
                // Используем закэшированный URL
                sceneEffectAudio.src = assetCacheMap.get(scene.effectAudio) || scene.effectAudio;
                sceneEffectAudio.load();
                sceneEffectAudio.play().catch(e => console.warn("Не удалось запустить эффект аудио:", e));
            }

            if (scene.musicAudio) {
                // Используем закэшированный URL
                sceneMusicAudio.src = assetCacheMap.get(scene.musicAudio) || scene.musicAudio;
                // Устанавливаем громкость (по умолчанию 1.0, если не указана)
                sceneMusicAudio.volume = scene.musicVolume !== undefined ? scene.musicVolume : 1.0; 
                sceneMusicAudio.load();
                sceneMusicAudio.play().catch(e => console.warn("Не удалось запустить фоновую музыку:", e));
            }
            // -----------------------------
            
            // 2. Обновляем видео и запускаем
            // Берем Blob URL из кэша (или исходный URL, если кэширование не удалось)
            videoElement.src = assetCacheMap.get(scene.videoUrl) || scene.videoUrl;
            videoElement.load();
            videoElement.muted = false; 
            
            // 3. Устанавливаем обработчик onended для этой сцены
            videoElement.onended = () => handleSceneEnd(sceneId);

            videoElement.play().catch(e => {
                console.log("Ошибка автозапуска видео:", e);
                // Если не удалось автовоспроизведение, показываем интерфейс, чтобы пользователь нажал Play вручную
                movieInterface.classList.add('active');
            });

            // 4. Обновляем текст и рендерим кнопки (если они есть)
            narrativeText.textContent = scene.text; 
            choicesContainer.innerHTML = ''; // Очищаем контейнер

            if (scene.choices && scene.choices.length > 0) {
                scene.choices.forEach(choice => {
                    const button = document.createElement('button');
                    button.textContent = choice.text;
                    button.className = 'choice-btn transition duration-200 ease-in-out text-base text-right';
                    
                    button.onclick = () => {
                        Array.from(choicesContainer.children).forEach(btn => btn.disabled = true);
                        
                        saveProgress(choice.nextId);
                        loadScene(choice.nextId);
                    };
                    choicesContainer.appendChild(button);
                });
            }
            // Кнопки пока не показываются, они будут показаны только после onended
        }

        // --- Новая функция: Показ начальной кнопки (только кнопка) ---
        function showStartButtonScreen() {
            // Удаляем старый слушатель на случай, если он был
            loadingScreen.removeEventListener('click', startGame);

            // 1. Очищаем экран от всего контента (включая скрытый текст)
            loadingScreen.innerHTML = ''; 

            // 2. Создаем кнопку "Войти в Пустошь"
            const startButton = document.createElement('button');
            startButton.id = 'wasteland-start-btn';
            startButton.textContent = 'В О Й Т И   В   П У С Т О Ш Ь';
            startButton.className = 'mt-0'; // Класс для центрирования на loading-screen (который flex-col)
            
            // 3. Добавляем только кнопку
            loadingScreen.appendChild(startButton);

            // 4. Назначаем обработчик клика, который начнет загрузку
            startButton.onclick = startLoading;
        }

        // --- Новая функция: Запуск загрузки ассетов и музыки ---
        function startLoading() {
            // 1. Убираем кнопку
            const startButton = document.getElementById('wasteland-start-btn');
            if (startButton) startButton.remove();
            
            // 2. Добавляем обратно элементы текста загрузки в DOM
            loadingScreen.appendChild(loadingTitle);
            loadingScreen.appendChild(loadingStatus);
            
            // 3. Обновляем текст загрузки и делаем видимым
            loadingTitle.classList.remove('hidden');
            loadingStatus.classList.remove('hidden');
            loadingTitle.textContent = 'З А Г Р У З К А';
            loadingTitle.classList.add('animate-pulse');
            loadingStatus.textContent = 'Начинаем загрузку ассетов...';

            // 4. Запускаем музыку (работает, так как это происходит после клика)
            loadingAudio.volume = 0.5; 
            loadingAudio.play().catch(e => console.warn("Не удалось запустить музыку:", e));

            // 5. Начинаем загрузку ассетов
            preloadAssets().then(() => {
                // 6. Когда загрузка завершена, переходим к экрану готовности
                showReadyScreen();
            });
        }

        // --- Обновленная функция: Показ экрана готовности (после загрузки) ---
        function showReadyScreen() {
            loadingTitle.textContent = 'Н А Ж М И Т Е';
            loadingTitle.classList.remove('animate-pulse');
            loadingStatus.textContent = 'чтобы начать игру';
            
            loadingScreen.style.cursor = 'pointer';
            loadingScreen.addEventListener('click', startGame, { once: true });
        }
        
        // --- Обновленная функция: Запуск игры (после второго клика) ---
        function startGame() {
            // 1. Плавное скрытие загрузочного экрана
            loadingScreen.style.opacity = '0';
            
            setTimeout(() => {
                loadingScreen.remove();
                loadingAudio.pause(); // Останавливаем загрузочную музыку
                
                videoContainer.style.opacity = '1'; 
                
                const currentSceneId = loadProgressLocal();
                loadScene(currentSceneId);

            }, 500); 
        }

        // --- Инициализация игры (только показ кнопки) ---
        showStartButtonScreen(); 
    </script>
</body>
</html>
